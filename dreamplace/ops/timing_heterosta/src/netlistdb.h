/**
 * The NetlistDB C-compatible builder interface.
 * C-FFI bindings to the Rust world.
 *
 * @author Guangxin Xiang
 */

#ifndef netlistdb_rs_bindings_h
#define netlistdb_rs_bindings_h

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The netlist storage.
 *
 * The public members are all READ-ONLY outside. Please modify
 * them through the ECO commands that will be available
 * in the future.
 */
typedef struct NetlistDB NetlistDB;

/**
 * This is a C-compatible netlist database interface
 * that one need to build on their C-side and passed into
 * [netlistdb_new].
 *
 * Currently it only has basic functionality.
 * Various functions like hierarchy parsing and constant-tied
 * nets (0/1) are NOT supported.
 */
typedef struct NetlistDBCppInterface {
  /**
   * Gives the top design name as a NULL-terminated string.
   *
   * If this is not a valid string, the top design name
   * will be set to empty.
   */
  const char *top_design_name;
  /**
   * Gives the number of cells
   */
  uintptr_t num_cells;
  /**
   * Gives the number of pins
   */
  uintptr_t num_pins;
  /**
   * Gives the number of top-level ports
   */
  uintptr_t num_ports;
  /**
   * Gives the number of nets
   */
  uintptr_t num_nets;
  /**
   * Gives the number of nets that are tied to 0.
   */
  uintptr_t num_nets_zero;
  /**
   * Gives the number of nets that are tied to 1.
   */
  uintptr_t num_nets_one;
  /**
   * Gives an array of pointers to NULL-terminated string,
   * indicating the cell names.
   *
   * The cell name hierarchy is NOT handled at this moment.
   * If the name contains '/', it will not be interpreted,
   * but will rather be treated as a whole name.
   */
  const char *const *cellname_array;
  /**
   * Gives an array of pointers to NULL-terminated string,
   * indicating the cell macro types (e.g., ANDV1).
   */
  const char *const *celltype_array;
  /**
   * Gives an array of pointers to NULL-terminated string,
   * indicating the pin names.
   *
   * The pin name hierarchy is NOT handled at this moment.
   * If the name contains '/', it will not be interpreted,
   * but will rather be treated as a whole name.
   *
   * The pin macro type (the short string follow ':') will
   * be parsed separately though.
   * If there is no ':' in the string given, the pin will
   * be treated as a top port.
   */
  const char *const *pinname_array;
  /**
   * Gives an array of pointers to NULL-terminated string,
   * indicating the net names.
   *
   * The net name hierarchy is NOT handled at this moment.
   * If the name contains '/', it will not be interpreted,
   * but will rather be treated as a whole name.
   */
  const char *const *netname_array;
  /**
   * Gives an array of u8 the length of num_pins,
   * each represents a direction.
   *
   * 0 means input ([Direction::I]),
   * 1 means output ([Direction::O]),
   * all others will be treated as [Direction::Unknown].
   *
   * Caution: the input and output follows a
   * standard-cell-oriented definition. This means a top
   * input port is actually an **output** pin, and vice versa.
   * If your external database defines it differently,
   * you need to invert the direction of top ports before
   * filling in this struct.
   */
  const uint8_t *pindirection_array;
  /**
   * Gives an array of cell indices that each pin belongs to.
   */
  const uintptr_t *pin2cell_array;
  /**
   * Gives an array of net indices that each pin belongs to.
   *
   * The net to pin CSR will be built according to this.
   * It will then be ordered according to the direction given.
   */
  const uintptr_t *pin2net_array;
  /**
   * Gives an array of net indices that are tied to 0.
   */
  const uintptr_t *nets_zero_array;
  /**
   * Gives an array of net indices that are tied to 1.
   */
  const uintptr_t *nets_one_array;
} NetlistDBCppInterface;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Build a Rust-side netlistdb object from the given
 * C-compatible netlist information ([NetlistDBCppInterface]).
 *
 * The returning pointer **owns** a **[Box]** of [NetlistDB],
 * that must be retrieved in other Rust code using
 * [Box::from_raw].
 */
struct NetlistDB *netlistdb_new(const struct NetlistDBCppInterface *netlist_ptr);

/**
 * Converts a placement nodeid to a timer cellid by adjusting the value of `nodeid`.
 *
 * - `nodeid` and `cellid` are identifiers used in different contexts.
 *   - `nodeid`: Represents the identifier used in the placement or netlist domain.
 *   - `cellid`: Represents the identifier used in the timing analysis (`timer`) domain.
 * - The difference arises because the `timer` internally maintains identifiers for
 *   the top-level design.
 *
 * - The return value represents the corresponding index of the cell in the `timer` netlist database.
 */
uintptr_t convert_place_nodeid_to_timer_cellid(uintptr_t nodeid);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* netlistdb_rs_bindings_h */
