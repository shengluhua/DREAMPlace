/**
 * HeteroSTA C-compatible API.
 *
 * Copyright (C) 2025 PKU EDA, all rights reserved.
 * Obtain a license and view the documentation at
 * https://heterosta.pkueda.org.cn/
 */

#ifndef HETEROSTA_RS_BINDINGS_H
#define HETEROSTA_RS_BINDINGS_H

#define HETEROSTA_PRODUCT_RELEASE

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * types of directions: input or output.
 *
 * note: inout is not supported yet.
 * **should be identical to `csrc/lib.h`**.
 */
enum NetlistDirection
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  /**
   * input
   */
  I = 0,
  /**
   * output
   */
  O = 1,
  /**
   * unknown (unassigned)
   */
  Unknown = 2,
};
#ifndef __cplusplus
typedef uint8_t NetlistDirection;
#endif // __cplusplus

/**
 * Type of a parasitic element. Only R & C
 */
enum ParasiticElementType
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  R = 0,
  C = 1,
};
#ifndef __cplusplus
typedef uint8_t ParasiticElementType;
#endif // __cplusplus

enum TimerEarlyOrLate
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  EARLY = 0,
  LATE = 1,
};
#ifndef __cplusplus
typedef uint8_t TimerEarlyOrLate;
#endif // __cplusplus

enum TimerRiseOrFall
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  RISE = 0,
  FALL = 1,
};
#ifndef __cplusplus
typedef uint8_t TimerRiseOrFall;
#endif // __cplusplus

/**
 * The netlist storage.
 *
 * The public members are all READ-ONLY outside. Please modify
 * them through the ECO commands that will be available
 * in the future.
 */
typedef struct NetlistDB NetlistDB;

/**
 * A path collection.
 */
typedef struct PBAPathCollection PBAPathCollection;

/**
 * The all-in-one simple STA database.
 *
 * For simplicity, assuming a single parasitics corner.
 */
typedef struct STAHoldings STAHoldings;

/**
 * A parasitic element.
 */
typedef struct ParasiticElement {
  /**
   * the type of element
   */
  ParasiticElementType typ;
  /**
   * id of one side of the element
   */
  uint32_t a;
  /**
   * id of another side.
   *
   * for grounded caps, this is set to [u32::MAX].
   *
   * Note that for our LU decomposition algorithm to
   * work properly, `a < b` must hold. our flattening
   * process has handled necessary swappings.
   */
  uint32_t b;
  /**
   * the value (e.g., resistance or capacitance).
   *
   * The value is normalized to the global units defined in
   * [`sta_unit`].
   */
  float value;
} ParasiticElement;

/**
 * FFI struct for [`FlattenedParasitics`].
 *
 * All pointers are raw pointers to CPU memory.
 */
typedef struct FlattenedParasiticsFFI {
  /**
   * number of nets. should be identical to [netlistdb::NetlistDB].
   */
  uintptr_t num_nets;
  /**
   * the prefix sum of the node numbers of all nets.
   *
   * be aware that this is different from the CSR array
   * in [`NetlistDB::net2pin`], because we include Steiner
   * points.
   */
  const uintptr_t *nodes_st;
  /**
   * the prefix sum of the number of RC elements.
   */
  const uintptr_t *elements_st;
  /**
   * all RC elements.
   *
   * For resistances and coupling capacitances, the (a, b) pairs
   * must be unique. However, for grounded capacitances, (a, MAX)
   * can repeat itself (which then add up).
   * This is for convenience in flattening where we turn foreign
   * coupling capacitances to grounded capacitances before SI analysis
   * is to be implemented.
   */
  const struct ParasiticElement *elements;
} FlattenedParasiticsFFI;

/**
 * One physical pin information.
 *
 * Pin information consists of caps and thresholds.
 * They originally come from Liberty file, but can be overriden
 * outside using special SDC commands on individual pins.
 *
 * This struct is specially defined for C kernels processing.
 * Unrelated fields (e.g., clock flags) should be put otherwhere,
 * e.g., in `FlattenedLibertyPin`.
 */
typedef struct LibPinInfo {
  /**
   * pin direction.
   */
  NetlistDirection direction;
  /**
   * pin capacitance (R/F)
   */
  float caps[2];
  /**
   * pin max capacitance
   */
  float max_cap;
  /**
   * pin max transition
   */
  float max_tran;
  /**
   * pin max fanout
   */
  float max_fanout;
  /**
   * The slew derate in `slew_derate_from_library`.
   */
  float slew_derate;
  /**
   * The delay threshold between 0 and 1. E.g., 0.5
   *
   * * (R/F)
   */
  float delay_threshold[2];
  /**
   * The slew thresholds between 0 and 1. E.g., (0.2, 0.8)
   *
   * * (R/F)
   */
  float slew_threshold[2][2];
} LibPinInfo;

/**
 * One reference to LUT.
 *
 * If not valid, the data_start will be set to
 * [`usize::MAX`].
 */
typedef struct LUTReference {
  /**
   * lut data (including indices and values) offset in
   * [`FlattenedLiberty::tables`].
   */
  uintptr_t data_start;
  /**
   * axis1 size
   */
  uint32_t axis1;
  /**
   * axis2 size
   */
  uint32_t axis2;
} LUTReference;

/**
 * One NLDM timing arc in Liberty.
 *
 * In the future, should be a C-compatible union-like type
 * supporting other cell delay models such as CCS.
 * Also, the power model could be added.
 *
 * I don't know if the table can be different between input rise or
 * fall, or is there only one possible LUT but is conditionally
 * applied using timing_sense or timing_type rising/falling_edge
 */
typedef struct TimingArcPointer {
  /**
   * cell_{rise/fall} * {input_rise/fall}
   *
   * index by \[frf\]\[trf\].
   */
  struct LUTReference delay[2][2];
  /**
   * {rise/fall}_trans * {input_rise/fall}
   *
   * index by \[frf\]\[trf\].
   */
  struct LUTReference slew[2][2];
  /**
   * {rise/fall}_trans * {input_rise/fall}
   *
   * index by \[frf\]\[trf\].
   */
  float drive_resistance[2][2];
} TimingArcPointer;

/**
 * The path collection.
 */
typedef struct PBAPathCollectionCppInterface {
  /**
   * Number of paths in the collection.
   */
  uintptr_t num_paths;
  /**
   * The slacks of paths.
   */
  const float *slacks;
  /**
   * The CSR start indices of pins (with R/F bit) inside every path.
   */
  const uintptr_t *path_st;
  /**
   * The path pins storage, CSR-indiced by `path_st`.
   */
  const uintptr_t *pin_rfs;
  /**
   * The pin arrival time.
   */
  const float *pin_at;
  /**
   * Pointer to the internal PBAPathCollection object.
   */
  struct PBAPathCollection *_pba_collection_ptr;
} PBAPathCollectionCppInterface;

/**
 * The cell information in Liberty.
 *
 * Cell information consists of leakage power and dont_touch attributes.
 */
typedef struct LibCellInfo {
  /**
   * The cell area in square micrometers (µm²).
   */
  float area;
  /**
   * The max leakage power.
   */
  float max_leakage_power;
  /**
   * The dont use attribute.
   */
  bool dont_use;
  /**
   * The dont touch attribute.
   */
  bool dont_touch;
  /**
   * Whether this cell is sequential.
   */
  bool is_sequential;
  /**
   * The max intrinsic delay of all arcs,
   * indexed by (frf << 1 | trf). frf is related (CK) pin rise/fall,
   * trf is current (D) pin rise/fall.
   */
  float max_intrinsic_delay[4];
  /**
   * The mean intrinsic delay of all arcs,
   * indexed by (frf << 1 | trf). frf is related (CK) pin rise/fall,
   * trf is current (D) pin rise/fall.
   */
  float mean_intrinsic_delay[4];
} LibCellInfo;

/**
 * Represents a collection of cell footprints, including associated cell types and cell information.
 */
typedef struct CellFootprints {
  /**
   * The total number of cell footprints.
   */
  uintptr_t num_cell_footprints;
  /**
   * A Pointer to an array storing the number of cell types for each footprint.
   *  (size: `num_cell_footprints`)
   */
  const uintptr_t *num_cell_types_for_footprints;
  /**
   * A Pointer to an array of C strings representing footprint names.
   *  (size: `num_cell_footprints`)
   */
  const char *const *cell_footprints;
  /**
   * A Pointer to a flattened array of C strings containing all cell type names.
   *  (size: `cell_st[num_cell_footprints]`)
   */
  const char *const *celltypes;
  /**
   * A Pointer to a flattened array of LibCellInfo structures.
   *  (size: `cell_st[num_cell_footprints]`)
   */
  const struct LibCellInfo *const *cellinfos;
  /**
   * Pointer to an array of starting indices for each footprint's cell types in the flattened arrays.
   *  (size: `num_cell_footprints + 1`)
   */
  const uintptr_t *cell_st;
  /**
   * A Pointer to a flattened array of LibPinInfo structures.
   *  (size: `cell_pin_st[cell_st[num_cell_footprints]]`)
   */
  const struct LibPinInfo *const *pininfos;
  /**
   * A Pointer to a flattened array of C strings containing all pin type names.
   *  (size: `cell_pin_st[cell_st[num_cell_footprints]]`)
   */
  const char *const *pintypes;
  /**
   * Pointer to an array of starting indices for each footprint's pin types in the flattened arrays.
   *  (size: `cell_st[num_cell_footprints] + 1`)
   */
  const uintptr_t *cell_pin_st;
} CellFootprints;

/**
 * A collection structure for netlist port information.
 *
 * This structure holds information about the design's top-level ports,
 * including port names and their corresponding pin information.
 */
typedef struct NetlistPortCollection {
  /**
   * Number of ports in the collection.
   */
  uintptr_t num_ports;
  /**
   * A Pointer to a flattened array of C strings containing all port names.
   *  (size: `num_ports`)
   */
  const char *const *port_names;
  /**
   * A Pointer to a flattened array of LibPinInfo structures.
   *  (size: `num_ports`)
   */
  const struct LibPinInfo *const *port_pin_infos;
} NetlistPortCollection;

/**
 * The LibPinInfo collection
 */
typedef struct LibPinInfoCollection {
  /**
   * Number of pins in the collection.
   */
  uintptr_t num_pins;
  /**
   * A Pointer to a flattened array of LibPinInfo structures.
   *  (size: `num_pins`)
   */
  const struct LibPinInfo *const *pininfos;
  /**
   * A Pointer to a flattened array of C strings containing all pin type names.
   *  (size: `num_pins`)
   */
  const char *const *pintypes;
} LibPinInfoCollection;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the HeteroSTA license. Returns true if succeeded.
 *
 * This is the first thing we need to do. Without a valid
 * license, `heterosta_new` will return a null pointer.
 * Note you can obtain one at [https://heterosta.pkueda.org.cn/].
 */
bool heterosta_init_license(const char *lic);

/**
 * Initialize the built-in logger at Rust side.
 *
 * For coherence with dreamplace, this initialization gives stdout logging
 * without color.
 */
void heterosta_init_logger(void (*dreamplace_print_callback)(uint8_t level, const char *message));

/**
 * Set the max print count for tagged Rust logger.
 */
void heterosta_logger_set_max_print_count(uint64_t c);

/**
 * Create a new heterosta instance on heap, and return its opaque pointer.
 *
 * The pointer should be freed using [`heterosta_free`] afterwards.
 */
struct STAHoldings *heterosta_new(void);

/**
 * Keep liberty and clear all other data.
 */
void heterosta_reset(struct STAHoldings *sta);

/**
 * Free a previously created heterosta instance.
 */
void heterosta_free(struct STAHoldings *sta);

/**
 * Set and initialize the Elmore delay calculator.
 *
 * This is 100% exactly the same as OpenTimer, and
 * 0.81 R2 (16% MRE) w.r.t. PrimeTime.
 * A better MRE but worse R2 compared to the scaled Elmore version.
 */
void heterosta_set_delay_calculator_elmore(struct STAHoldings *sta);

/**
 * Set and initialize the Elmore delay calculator (scaled).
 *
 * This is 0.996 R2 (4% MRE) w.r.t. OpenSTA simplerc delay calculator,
 * and 0.956 R2 (24% MRE) w.r.t. PrimeTime.
 */
void heterosta_set_delay_calculator_elmore_scaled(struct STAHoldings *sta);

/**
 * Set and initialize the Arnoldi delay calculator.
 *
 * This is 0.982 R2 (7.4% MRE) w.r.t. PrimeTime.
 * It has even better MRE than the OpenSTA Arnoldi calculator.
 */
void heterosta_set_delay_calculator_arnoldi(struct STAHoldings *sta);

/**
 * Read a liberty library file at the specified path.
 *
 * `el` is the library type. 0 means early, and 1 means late.
 * If a library is to be used for both early and late ones, it should
 * be read twice by calling this twice.
 * Returns whether the read has succeeded. false means failure.
 */
bool heterosta_read_liberty(struct STAHoldings *sta, TimerEarlyOrLate el, const char *path);

/**
 * Reads multiple liberty library files in parallel.
 *
 * - `el`: Specifies the library type. 0 means early, 1 means late.
 * - `paths`: An array of C string pointers, each representing a liberty file path.
 * - `num_libs`: The number of paths in the array.
 *
 * All files will be parsed in parallel (multi-threaded across files),
 * but each individual file is parsed using a single thread.
 * Successfully parsed libraries will be merged into the corresponding STA database.
 * Returns true if at least one file is successfully parsed, false if all fail.
 */
bool heterosta_batch_read_liberty(struct STAHoldings *sta,
                                  TimerEarlyOrLate el,
                                  const char *const *paths,
                                  uintptr_t num_libs);

/**
 * Read a netlist verilog file at the specified path.
 *
 * Should be done after reading all liberty libraries.
 * If `top_module` is not NULL, will regard the provided module type
 * as the top module.
 * Returns whether the read has succeeded. false means failure.
 */
bool heterosta_read_netlist(struct STAHoldings *sta, const char *path, const char *top_module);

/**
 * Read a SPEF parasitics file at the specified path.
 *
 * In principle, can be parallelized with `heterosta_read_netlist`.
 * Returns whether the read has succeeded. false means failure.
 */
bool heterosta_read_spef(struct STAHoldings *sta, const char *path);

/**
 * Build FlattenedParasitics from FFI struct.
 */
void heterosta_build_flatten_parasitics(struct STAHoldings *sta,
                                        const struct FlattenedParasiticsFFI *ffi,
                                        bool use_cuda);

/**
 * Flatten all internal design databases.
 *
 * Should be called just after reading liberty, netlist,
 * (and optionally spef).
 */
void heterosta_flatten_all(struct STAHoldings *sta);

/**
 * Extract simple parasitics given pin positions and unit RC.
 *
 * Use FLUTE internally.
 * xs and ys are x and y coordinates. they should reside on GPU if
 * use_cuda is true.
 * The coordinates are indexed by INTERNAL pin orders. The pin orders
 * from external databases might need a reshuffle before being fed here.
 *
 * Parameters:
 * - `sta`: Mutable reference to the STAHoldings structure containing timing data.
 * - `xs`: Pointer to an array of x coordinates (f32).
 * - `ys`: Pointer to an array of y coordinates (f32).
 * - `unit_cap_x`: Unit capacitance in x direction (fF).
 * - `unit_cap_y`: Unit capacitance in y direction (fF).
 * - `unit_res_x`: Unit resistance in x direction (kOhm).
 * - `unit_res_y`: Unit resistance in y direction (kOhm).
 * - `via_res`: Via resistance in kOhm (default: 0.0).
 * - `flute_accuracy`: Accuracy of the FLUTE algorithm (u32).
 * - `pdr_alpha`: Alpha parameter for PDR algorithm (f32).
 * - `use_flute_or_pdr`: 0 for FLUTE, 1 for PDR.
 * - `use_cuda`: Whether to use CUDA (GPU) for computation (true) or CPU (false).
 */
void heterosta_extract_rc_from_placement(struct STAHoldings *sta,
                                         const float *xs,
                                         const float *ys,
                                         float unit_cap_x,
                                         float unit_cap_y,
                                         float unit_res_x,
                                         float unit_res_y,
                                         float via_res,
                                         uint32_t flute_accuracy,
                                         float pdr_alpha,
                                         uint8_t use_flute_or_pdr,
                                         bool use_cuda);

/**
 * Reconstruct FlattenedParasitics back into SPEF at the specified file path.
 *
 * Should ensure that FlattenedParasitics has been constructed before calling,
 * that means it should be called after read_spef or extract_rc_from_placement
 * is finished.
 * Returns whether the write has succeeded. false means failure.
 */
bool heterosta_write_spef(const struct STAHoldings *sta, const char *spef_path);

/**
 * Build the STA graph.
 *
 * Should be called just after reading liberty and netlist, and before
 * slew, SDC, and delay operations.
 * No parasitics is needed for building it.
 */
void heterosta_build_graph(struct STAHoldings *sta);

/**
 * Obtain in a bool vector whether each pin is a timing endpoint.
 *
 * The vector is indexed by INTERNAL pin orders, same as slacks.
 * Should be called just after building timing graph.
 * This is useful in TNS calculation.
 */
void heterosta_get_is_endpoint(const struct STAHoldings *sta, bool *is_endpoint);

/**
 * Zero initialize input port slews.
 *
 * Should be called optionally before reading SDC.
 */
void heterosta_zero_slew(struct STAHoldings *sta);

/**
 * Read a SDC constraints file at the specified path.
 *
 * Should be called after building the graph.
 * Returns whether the read has succeeded. false means failure.
 */
bool heterosta_read_sdc(struct STAHoldings *sta, const char *path);

/**
 * Update arcs delay in parallel.
 */
void heterosta_update_delay(struct STAHoldings *sta, bool use_cuda);

/**
 * Update pin arrival times and required arrival times in parallel.
 */
void heterosta_update_arrivals(struct STAHoldings *sta, bool use_cuda);

/**
 * Update the timing gradient for all cells in parallel.
 *
 * This function computes the timing gradient (with respect to cell positions or other variables)
 * for all cells in the design, using the specified gamma parameter. The computation can be performed
 * on CPU or GPU depending on the use_cuda flag. After updating, it also reports the gradient at the
 * cell with the maximum value.
 *
 * Parameters:
 * - sta: Mutable reference to the STAHoldings structure containing timing data.
 * - gamma: The smoothing parameter for the gradient calculation.
 * - use_cuda: Whether to use CUDA (GPU) for computation (true) or CPU (false).
 */
void heterosta_update_timing_grad(struct STAHoldings *sta,
                                  float gamma,
                                  bool use_cuda);

/**
 * Report the pin/risefall slacks that come from max condition.
 * If this slack is negative, the pin's arrival time has to be
 * *faster* in order to solve it.
 *
 * For datapath pins, this is equivalent to *setup* slack. For
 * clock pins, this might come from capturing *hold* slack as well.
 *
 * The given slack buffer should be exactly `num_pins` in size,
 * with each pin two float32's. (i.e., `2*num_pins` float32's)
 * The buffer should be on GPU memory if use_cuda is true.
 *
 * The pin slacks are indexed by INTERNAL pin orders.
 * The pin orders might need a reversed reshuffle before used in
 * external databases.
 */
void heterosta_report_slacks_at_max(const struct STAHoldings *sta,
                                    float (*slack)[2],
                                    bool use_cuda);

/**
 * Report pin/risefall slacks that come from min condition.
 * If this slack is negative, the pin's arrival time has to be
 * *slower* in order to solve it.
 *
 * For datapath pins, this is equivalent to *hold* slack. For
 * clock pins, this might come from capturing *setup* slack as well.
 *
 * The given slack buffer should be exactly `num_pins` in size,
 * with each pin two float32's. (i.e., `2*num_pins` float32's)
 * The buffer should be on GPU memory if use_cuda is true.
 *
 * The pin slacks are indexed by INTERNAL pin orders.
 * The pin orders might need a reversed reshuffle before used in
 * external databases.
 */
void heterosta_report_slacks_at_min(const struct STAHoldings *sta,
                                    float (*slack)[2],
                                    bool use_cuda);

/**
 * Report worst negative slack (WNS) and total negative slack (TNS) for setup or hold checks.
 *
 * The function must have been called after `heterosta_update_arrivals` and `heterosta_update_delay`.
 *
 * ## Parameters
 * - `sta`: A reference to the `STAHoldings` object.
 * - `wns`: A mutable pointer to a float where the Worst Negative Slack will be stored.
 * - `tns`: A mutable pointer to a float where the Total Negative Slack will be stored.
 * - `report_max`: If true, reports setup WNS/TNS. If false, reports hold WNS/TNS.
 * - `use_cuda`: A boolean flag indicating whether to use CUDA for the computation.
 *
 * ## Returns
 * `true` if the report was generated successfully, `false` otherwise.
 */
bool heterosta_report_wns_tns(const struct STAHoldings *sta,
                              float *wns,
                              float *tns,
                              bool report_max,
                              bool use_cuda);

/**
 * Print the timing report of the first num setup timing paths to the file.
 *
 * ## Parameters
 * - `sta`: A reference to the `STAHoldings` structure.
 * - `num_paths`: The number of paths to dump.
 * - `nworst`: The number of worst paths to dump for each endpoint.
 * - `split_endpoint_rf`: If true, treats rise/fall transitions at the same endpoint as two
 *    separate endpoints for path analysis. This affects nworst path calculations.
 * - `file_path`: The path to the output file.
 * - `use_cuda`: A boolean indicating whether to use CUDA for processing.
 */
void heterosta_dump_paths_setup_to_file(const struct STAHoldings *sta,
                                        uintptr_t num_paths,
                                        uintptr_t nworst,
                                        bool split_endpoint_rf,
                                        const char *file_path,
                                        bool use_cuda);

/**
 * Print the timing report of setup or hold timing paths to a file.
 *
 * ## Parameters
 * - `sta`: A reference to the `STAHoldings` structure.
 * - `num_paths`: The number of paths to dump.
 * - `nworst`: The number of worst paths to dump for each endpoint.
 * - `split_endpoint_rf`: If true, treats rise/fall transitions at the same endpoint as two
 *    separate endpoints for path analysis. This affects nworst path calculations.
 * - `report_max`: A boolean flag to select the path type. If `true`, dumps setup paths. If `false`, dumps hold paths.
 * - `file_path`: The path to the output file.
 * - `use_cuda`: A boolean indicating whether to use CUDA for processing.
 */
void heterosta_dump_paths_to_file(const struct STAHoldings *sta,
                                  uintptr_t num_paths,
                                  uintptr_t nworst,
                                  bool split_endpoint_rf,
                                  bool report_max,
                                  const char *file_path,
                                  bool use_cuda);

/**
 * Dump a SDF delay file to the specified out path.
 *
 * Returns whether the file write has succeeded. false means failure.
 */
bool heterosta_report_delay_sdf(const struct STAHoldings *sta, const char *path);

/**
 * Search for a pin name and returns its internal index.
 *
 * The pin name can contain hierarchy (sep /) and bit (brackets []).
 * If not found, will return `usize::MAX`.
 * Only available after reading netlist. Different lookups can be
 * parallelized.
 */
uintptr_t heterosta_lookup_pin(const struct STAHoldings *sta, const char *pin_name);

/**
 * Set a net to be skipped during placement rc extraction, given
 * a pin index contained in that net.
 */
void heterosta_set_skip_net_with_pin(struct STAHoldings *sta, uintptr_t pin_id);

/**
 * Launch a debug Tcl shell.
 *
 * In the shell, you can use commands like
 * `internal_debug_pin_arrivals` to print useful debug info.
 */
void heterosta_launch_debug_shell(struct STAHoldings *sta);

/**
 * Clone a timer instance.
 */
struct STAHoldings *heterosta_clone(const struct STAHoldings *sta);

/**
 * Obtain a pointer to the internal pininfo tensor state.
 *
 * pininfo contains pin capacitances (rise/fall), and
 * delay and slew thresholds (0 to 1)
 */
const struct LibPinInfo *heterosta_get_port_drivers(const struct STAHoldings *sta,
                                                    TimerEarlyOrLate early_or_late,
                                                    bool use_cuda);

/**
 * Query the liberty pin info (caps, etc) of a macro pin.
 *
 * on success, returns a pointer to LibPinInfo on CPU.
 * on failure, returns NULL.
 */
const struct LibPinInfo *heterosta_query_macro_pin(const struct STAHoldings *sta,
                                                   TimerEarlyOrLate early_or_late,
                                                   const char *celltype,
                                                   const char *pintype);

/**
 * Checks if a given net index is on the clock network.
 *
 * - `sta`: A reference to the `STAHoldings` structure containing the static timing analysis data.
 * - `netid`: The net index to be checked.
 *
 * - `true` if the specified `netid` is found in the `clock_network_nets` set within `sta_graph`.
 * - `false` otherwise.
 */
bool heterosta_is_clock_network_net(const struct STAHoldings *sta, uintptr_t netid);

/**
 * This function get all net index associated with the clock network.
 *
 * - `sta`: A reference to the `STAHoldings` structure, which holds static timing data.
 * - `nets`: A mutable pointer to an array of `usize`. This array will be populated with the indices
 *   of the clock network nets. It must be large enough to hold all the indices.
 *
 * - Returns the total number of clock network nets. The caller can use this value to determine how
 * many elements in the `nets` array are valid.
 *
 * ## Important Note:
 * The ideal network consists of both ideal clock networks and non-ideal clock networks.
 *
 * ## Example (C++):
 * ```cpp
 *
 * std::vector<uintptr_t> nets(placedb.num_nets);
 * uintptr_t num_clock_nets = heterosta_get_clock_network_nets(timer, nets.data());
 * nets.resize(num_clock_nets);
 * for (size_t i = 0; i < num_clock_nets; ++i) {
 *     std::cout << "Clock network net index: " << nets[i] << std::endl;
 * }
 * ```
 */
uintptr_t heterosta_get_clock_network_nets(const struct STAHoldings *sta, uintptr_t *nets);

/**
 * This function get all net index associated with the ideal_network in the SDC of `set_ideal_network`.
 *
 * - `sta`: A reference to the `STAHoldings` structure, which holds static timing data.
 * - `nets`: A mutable pointer to an array of `usize`. This array will be populated with the indices
 *   of the ideal network nets in the sdc of `set_ideal_network`. It must be large enough to hold all the indices.
 *
 * - Returns the total number of ideal network nets. The caller can use this value to determine how
 * many elements in the `nets` array are valid.
 * the usage same with `heterosta_get_clock_network_nets`.
 *
 * ## Important Note:
 * The sdc ideal network currently includes nes configured as propagated networks through the `set_ideal_network` SDC.
 */
uintptr_t heterosta_get_sdc_ideal_network_nets(const struct STAHoldings *sta,
                                               uintptr_t *nets);

/**
 * Query the pin capacitance value by pin index.
 *
 * on success, returns the capacitance value on the net where the pin is located.
 * on failure, returns 0.
 *
 * Parameters:
 * - `sta`: Reference to the STAHoldings structure.
 * - `early_or_late`: Timing context (0: early, 1: late).
 * - `pinid`: The pin index.
 */
float heterosta_query_pin_load(const struct STAHoldings *sta,
                               TimerEarlyOrLate early_or_late,
                               uintptr_t pinid);

/**
 * Query the pin upstream resistance value by pin index
 * (as an Elmore model perspective).
 * on success, returns the upstream resistance of the pin,
 * which is the total resistance from the source to the sink in the RC tree.
 * on failure, returns 0.
 *
 * Parameters:
 * - `sta`: Reference to the STAHoldings structure.
 * - `pinid`: The pin index.
 * - `early_or_late`: Timing context (0: early, 1: late).
 */
float heterosta_query_pin_upstream_res(const struct STAHoldings *sta,
                                       TimerEarlyOrLate early_or_late,
                                       uintptr_t pinid);

/**
 * Query the maximum capacitance of a pin as recorded in Liberty.
 *
 * This value is taken from the `max_cap` recorded in Liberty.
 * If `set_max_capacitance` is specified in the SDC file,
 * the minimum value between the SDC and Liberty will be used.
 *
 * If the liberty does not record a `default_max_capacitance`,
 * the function will return `NaN`. To resolve this, add
 * `set_max_capacitance xx [all_inputs]` in the SDC file.
 *
 * on success, returns the pin's maximum capacitance.
 * on failure, returns NaN.
 */
float heterosta_query_pin_max_load(const struct STAHoldings *sta,
                                   TimerEarlyOrLate early_or_late,
                                   uintptr_t pinid);

/**
 * Query the real transition time by pin index.
 *
 * If you want slew instead, you should multiply it by
 * your `slew_derate`.
 */
float heterosta_query_pin_transition(const struct STAHoldings *sta,
                                     TimerEarlyOrLate early_or_late,
                                     TimerRiseOrFall rise_or_fall,
                                     uintptr_t pinid);

/**
 * Query the maximum transition of a pin as recorded in Liberty.
 *
 * This value is taken from the `max_tran` recorded in Liberty.
 * If `set_max_transition` is specified in the SDC file,
 * the minimum value between the SDC and Liberty will be used.
 *
 * If the liberty does not record a `default_max_transition`,
 * the function will return `NaN`. To resolve this, add
 * `set_max_transition xx [all_outputs]` in the SDC file.
 *
 * on success, returns the pin's maximum transition.
 * on failure, returns NaN.
 */
float heterosta_query_pin_max_transition(const struct STAHoldings *sta,
                                         TimerEarlyOrLate early_or_late,
                                         uintptr_t pinid);

/**
 * Query the input capacitance of a pin as recorded in Liberty.
 *
 * This value is taken from the `capacitance` recorded in Liberty.
 * The unit is in femtofarads (fF).
 * on success, returns the pin's capacitance.
 * on failure, returns `NaN`.
 * If the pin is an input port or output port, the function will return `NaN`.
 * If the input or output load is set using `set_load` in the SDC, the function will return the load value.
 */
float heterosta_query_pin_cap(const struct STAHoldings *sta,
                              TimerEarlyOrLate early_or_late,
                              TimerRiseOrFall rise_or_fall,
                              uintptr_t pinid);

/**
 * Query the maximum fanout of a pin as recorded in Liberty.
 *
 * This value is taken from the `max_fanout` recorded in Liberty.
 * If `set_max_fanout` is specified in the SDC file,
 * the minimum value between the SDC and Liberty will be used.
 *
 * If the liberty does not record a `default_max_fanout`,
 * the function will return `NaN`.
 *
 * on success, returns the pin's maximum fanout.
 * on failure, returns NaN.
 */
float heterosta_query_pin_max_fanout(const struct STAHoldings *sta,
                                     TimerEarlyOrLate early_or_late,
                                     uintptr_t pinid);

/**
 * Query the cell type by pin index.
 *
 * on success, returns the cell type where where the pin is located.
 * on failure, returns NULL.
 *
 * The returned string reference is valid up to your next
 * API call that updates the timer database.
 */
const char *heterosta_get_celltype_of_pin(const struct STAHoldings *sta, uintptr_t pinid);

/**
 * Query the cell id by pin index.
 *
 * on success, returns the cell id where where the pin is located.
 * on failure, returns `usize::MAX`.
 */
uintptr_t heterosta_get_cellid_of_pin(const struct STAHoldings *sta, uintptr_t pinid);

/**
 * Query the cell name by cell id.
 *
 * on success, returns the cell name.
 * on failure, returns NULL.
 *
 * The returned string reference is valid up to your next
 * API call that updates the timer database.
 */
const char *heterosta_get_cellname_by_id(const struct STAHoldings *sta, uintptr_t cellid);

/**
 * Query the cell type by cell id.
 *
 * on success, returns the cell type.
 * on failure, returns NULL.
 *
 * The returned string reference is valid up to your next
 * API call that updates the timer database.
 */
const char *heterosta_get_celltype_by_id(const struct STAHoldings *sta, uintptr_t cellid);

/**
 * Query the pin type by pin index.
 *
 * on success, returns the pin type where where the pin is located.
 * on failure, returns NULL.
 *
 * The returned string reference is valid up to your next
 * API call that updates the timer database.
 */
const char *heterosta_get_pintype_of_pin(const struct STAHoldings *sta, uintptr_t pinid);

/**
 * Query the liberty name by pin index.
 *
 * on success, returns the liberty name where where the pin is located.
 * on failure, returns NULL.
 *
 * The returned string reference is valid up to your next
 * API call that updates the timer database.
 */
const char *heterosta_get_libname_of_pin(const struct STAHoldings *sta, uintptr_t pinid);

/**
 * Query the liberty arc info (caps, etc) of a macro arc.
 *
 * on success, returns a pointer to TimingArcPointer.
 * on failure, returns NULL.
 *
 * The returned string reference is valid up to your next
 * API call that updates the timer database.
 */
const struct TimingArcPointer *heterosta_query_macro_arc(const struct STAHoldings *sta,
                                                         TimerEarlyOrLate early_or_late,
                                                         const char *celltype,
                                                         const char *pintype,
                                                         const char *from_pintype,
                                                         bool use_cuda);

/**
 * Reset the PBA environment in timer.
 *
 * This allows you to apply a different SDC without
 * re-initializing the netlist or library database.
 */
void heterosta_reset_pba(struct STAHoldings *sta);

/**
 * Initialize the timer netlist database using an external
 * flattened database.
 *
 * You should transform your netlist into a `NetlistDB`
 * using APIs in `netlistdb.h`.
 */
void heterosta_set_netlistdb(struct STAHoldings *sta, struct NetlistDB *netlist_ptr);

/**
 * Get total leakage power
 *
 * Before calling this, `[heterosta_update_power]` should be called.
 * otherwise NaN will be returned.
 */
float heterosta_get_total_leakage_power(const struct STAHoldings *sta,
                                        TimerEarlyOrLate early_or_late);

/**
 * Update design power information.
 *
 * Currently only leakage power is supported.
 * Other power analysis will be supported in the future.
 */
void heterosta_update_power(struct STAHoldings *sta);

/**
 * Quickly changes the cell type of the given node in the netlist.
 *
 * This function changes the cell type associated with a specific node ID (which corresponds
 * to a cell ID in the netlist database) using the provided `cellname`.
 * Before calling this function, you must invoke `netlistdb_cellid_external_to_internal` to ensure that the `cellid` is properly adjusted.
 * It is essential to note that after calling `heterosta_change_celltype_by_nodeid`,
 * you should call `heterosta_update_delay` to update timing analysis.
 * This function performs the following steps:
 * 1. Checks whether the `function` and `footprint` of the new cell type
 *    are the same as the existing cell type.
 * 2. If they are the same, it updates the corresponding timing arcs for the cell.
 *
 * * `sta` - A mutable reference to the `STAHoldings` structure.
 * * `cellid`: The index of the cell in the timer's netlist database.
 * * `cellname` - A C-style string pointer representing the name of the cell to be assigned to the node.
 * This function uses raw pointers for interoperability with C. It is the caller's responsibility
 * to ensure that `cellname` is a valid, non-null C-style string. Additionally, since `sta` is
 * passed as a mutable reference, care must be taken to ensure no data races occur in a multithreaded context.
 */
bool heterosta_fast_update_celltype_by_cellid(struct STAHoldings *sta,
                                              uintptr_t cellid,
                                              const char *cellname);

/**
 * Batch update cell types for all cells in the design.
 *
 * This function receives an array of cell type names (C string pointers),
 * compares each with the current cell type in the netlist database, and updates
 * the cell type if it is different. The update logic is the same as `heterosta_fast_update_celltype_by_cellid`.
 *
 * Parameters:
 * - sta: Mutable reference to the STAHoldings structure containing timing data.
 * - celltypes: Pointer to an array of C string pointers, each representing a cell type name.
 * - num_cells: The number of cells (length of the celltypes array).
 *
 * Returns:
 * - The number of cells that were updated.
 */
uintptr_t heterosta_batch_update_celltypes(struct STAHoldings *sta,
                                           const char *const *celltypes,
                                           uintptr_t num_cells);

/**
 * This function generates a `PBAPathCollectionCppInterface` object and returns a raw pointer to it.
 * It reports the setup paths for timing analysis and prepares the data to be used in external C/C++ code.
 *
 * ## Parameters
 * - `sta`: A mutable reference to an `STAHoldings` object, which contains the timing analysis data structures.
 * - `num_paths`: The maximum number of paths to include in the collection.
 * - `nworst`: The maximum number of paths which can be reported for each endpoint. (`1u` or `std::numeric_limits<uintptr_t>::max()`)
 * - `slack_lesser_than`: The exclusive upper bound for slack values to be included in the collection (can be `std::numeric_limits<float>::max()`).
 * - `split_endpoint_rf`: If true, treats rise/fall transitions at the same endpoint as two separate endpoints for path analysis.
 *   This affects nworst path calculations.
 * - `use_cuda`: A boolean flag indicating whether CUDA should be used for computations.
 *
 * ## Returns
 * A raw pointer to a `PBAPathCollectionCppInterface` object, which contains path data such as slacks,
 * path start times, and pin references. The caller is responsible for freeing the allocated memory using
 * `heterosta_free_pba_path_collection`.
 *
 * ## Usage Example (in C++)
 * ```cpp
 * PBAPathCollectionCppInterface* path_interface = heterosta_report_paths_setup(sta, num_paths, nworst, slack_lesser_than, split_endpoint_rf, use_cuda, result_use_cuda);
 * // Use the `path_interface` object to access path data.
 * heterosta_free_pba_path_collection(path_interface); // Free the memory when done.
 * ```
 *
 * ## Notes:
 * - When `use_cuda` is `true`, the data will initially reside on the GPU.
 * - **The user must explicitly copy the data to the host memory** to access it on the CPU.
 */
struct PBAPathCollectionCppInterface *heterosta_report_paths_setup(const struct STAHoldings *sta,
                                                                   uintptr_t num_paths,
                                                                   uintptr_t nworst,
                                                                   float slack_lesser_than,
                                                                   bool split_endpoint_rf,
                                                                   bool use_cuda,
                                                                   bool result_use_cuda);

/**
 * This function generates a `PBAPathCollectionCppInterface` object and returns a raw pointer to it.
 * It reports timing paths (max/setup or min/hold) for timing analysis and prepares the data to be used in external C/C++ code.
 *
 * ## Parameters
 * - `sta`: A mutable reference to an `STAHoldings` object, which contains the timing analysis data structures.
 * - `num_paths`: The maximum number of paths to include in the collection.
 * - `nworst`: The maximum number of paths which can be reported for each endpoint. (`1u` or `std::numeric_limits<uintptr_t>::max()`)
 * - `slack_lesser_than`: The exclusive upper bound for slack values to be included in the collection (can be `std::numeric_limits<float>::max()`).
 * - `split_endpoint_rf`: If true, treats rise/fall transitions at the same endpoint as two separate endpoints for path analysis.
 *   This affects nworst path calculations.
 * - `report_max`: A boolean flag to select the path type. If `true`, reports max (setup) paths. If `false`, reports min (hold) paths.
 * - `use_cuda`: A boolean flag indicating whether CUDA should be used for computations.
 *
 * ## Returns
 * A raw pointer to a `PBAPathCollectionCppInterface` object, which contains path data such as slacks,
 * path start times, and pin references. The caller is responsible for freeing the allocated memory using
 * `heterosta_free_pba_path_collection`.
 *
 * ## Usage Example (in C++)
 * ```cpp
 * // To get max (setup) paths
 * PBAPathCollectionCppInterface* path_interface = heterosta_report_paths(sta, num_paths, nworst, slack_lesser_than, split_endpoint_rf, true, use_cuda, result_use_cuda);
 * // Use the `path_interface` object to access path data.
 * heterosta_free_pba_path_collection(path_interface); // Free the memory when done.
 * ```
 *
 * ## Notes:
 * - When `use_cuda` is `true`, the data will initially reside on the GPU.
 * - **The user must explicitly copy the data to the host memory** to access it on the CPU.
 */
struct PBAPathCollectionCppInterface *heterosta_report_paths(const struct STAHoldings *sta,
                                                             uintptr_t num_paths,
                                                             uintptr_t nworst,
                                                             float slack_lesser_than,
                                                             bool split_endpoint_rf,
                                                             bool report_max,
                                                             bool use_cuda,
                                                             bool result_use_cuda);

/**
 * Free a previously created PBAPathCollectionCppInterface instance.
 */
void heterosta_free_pba_path_collection(struct PBAPathCollectionCppInterface *pba_path_collection_ptr);

/**
 * Retrieves and constructs a `CellFootprints` structure based on the internal data.
 *
 * This function gathers information about cell footprints, including their names, associated cell types,
 * and cell type properties, and organizes the data into a `CellFootprints` structure.
 * It is typically used for exporting footprint data to external tools or C-compatible interfaces.
 *
 * # Safety
 * - The returned `CellFootprints` contains raw pointers to allocated memory. After the caller
 *   finishes using the `CellFootprints` structure, should call [`heterosta_free_cell_footprints`]
 *   to release the allocated memory and prevent memory leaks.
 *
 * # Usage
 * CellFootprints footprints = heterosta_get_cell_footprints(timer_, 1);
 * // Use the `footprints` object to access path data.
 * heterosta_free_cell_footprints(&footprints);
 *
 */
struct CellFootprints heterosta_get_cell_footprints(const struct STAHoldings *sta,
                                                    TimerEarlyOrLate early_or_late);

/**
 * Free a previously created CellFootprints instance.
 */
void heterosta_free_cell_footprints(struct CellFootprints *footprints);

/**
 * Calculate the NLDM arc delay of a cell based on the specified input/output points and conditions.
 *
 * This function computes the cell arc delay between the specified `from` and `to` pin types,
 * considering the given input transition time and output load.
 *
 * Parameters:
 * - sta: Pointer to the STAHoldings object.
 * - celltype: C string representing the cell type.
 * - from_pintype: C string representing the starting pin type.
 * - to_pintype: C string representing the destination pin type.
 * - from_rf: Rise/Fall state of the `from` point (0: rise, 1: fall).
 * - to_rf: Rise/Fall state of the `to` point (0: rise, 1: fall).
 * - input_transition: Input transition time (in time units).
 * - output_load: Output load (in capacitance units).
 *
 * Returns:
 * - The calculated cell arc delay as a float (ps).
 * - Returns NaN if timing arc is invalid.
 */
float heterosta_calc_cell_arc_delay_nldm_with_macro_pin(const struct STAHoldings *sta,
                                                        const char *celltype,
                                                        const char *from_pintype,
                                                        const char *to_pintype,
                                                        TimerRiseOrFall from_rf,
                                                        TimerRiseOrFall to_rf,
                                                        float input_transition,
                                                        float output_load);

/**
 * Calculate the arc delay of a cell based on the specified driver pin rf and output load.
 *
 * This function computes the cell arc delay for the most critical input pin of the specified driver pin rf.
 * It considers the output load and the driver pin's rise/fall state.
 *
 * If calibration is enabled, it will apply the calibrated delay based on the timing arc ID and the driver pin's rise/fall state.
 *
 * Parameters:
 * - sta: Pointer to the STAHoldings object.
 * - driver_pin_id: The driver pin id.
 * - driver_rf: The rise/fall state of the driver pin (0: rise, 1: fall).
 * - output_load: The output load (in capacitance units).
 * - early_or_late: early lib or late lib (0: early, 1: late).
 *
 * Returns:
 * - The calculated cell arc delay as a float (ps).
 * - Returns 0.0 if timing arc is invalid.
 */
float heterosta_calc_cell_arc_delay_nldm_with_netlist_driver_pin_rf(const struct STAHoldings *sta,
                                                                    uintptr_t driver_pin_id,
                                                                    TimerRiseOrFall driver_rf,
                                                                    float output_load,
                                                                    TimerEarlyOrLate early_or_late);

/**
 * Calculate the NLDM output transition time based on cell type and pin configuration.
 *
 * This function computes the output transition time for a specific cell,
 * considering the input and output pins, their rise/fall states, input transition,
 * and output load.
 *
 * Parameters:
 * - sta: Reference to the STAHoldings structure containing timing data.
 * - celltype: C string representing the cell type name.
 * - from_pintype: C string representing the input pin name.
 * - to_pintype: C string representing the output pin name.
 * - from_rf: Rise (0) or fall (1) state of the input signal.
 * - to_rf: Rise (0) or fall (1) state of the output signal.
 * - input_transition: Input transition time (in time units).
 * - output_load: Output load capacitance (in capacitance units).
 * - early_or_late: Whether to use early (0) or late (1) timing data.
 *
 * Returns:
 * - The calculated output transition time.
 * - Returns NaN if the timing arc is not found or invalid.
 */
float heterosta_calc_output_transition_nldm(const struct STAHoldings *sta,
                                            const char *celltype,
                                            const char *from_pintype,
                                            const char *to_pintype,
                                            TimerRiseOrFall from_rf,
                                            TimerRiseOrFall to_rf,
                                            float input_transition,
                                            float output_load,
                                            TimerEarlyOrLate early_or_late);

/**
 * Calculate the NLDM output transition time for a specific driver pin with given rise/fall state.
 *
 * This function identifies the critical input pin with minimum slack that drives the specified output pin,
 * and computes the output transition time based on the actual input slew and provided output load.
 *
 * Parameters:
 * - sta: Reference to the STAHoldings structure containing timing data.
 * - driver_pin_id: ID of the driver pin (output pin).
 * - driver_rf: Rise (0) or fall (1) state of the driver pin.
 * - output_load: Output load capacitance (in capacitance units).
 * - early_or_late: Whether to use early (0) or late (1) timing data.
 * - (out) output_transition_legal: Boolean indicating if the output transition is legal.
 * - (out) downstream_input_transition_legal: Boolean indicating if the downstream input transition is legal.
 *
 * Returns:
 * - The calculated output transition time.
 * - Returns NaN if no valid timing arc is found.
 */
float heterosta_calc_output_transition_nldm_with_pin_rf(const struct STAHoldings *sta,
                                                        uintptr_t driver_pin_id,
                                                        TimerRiseOrFall driver_rf,
                                                        float output_load,
                                                        TimerEarlyOrLate early_or_late,
                                                        bool *output_transition_legal,
                                                        bool *downstream_input_transition_legal);

/**
 * This function return the arc delay in timing path.
 * ## Parameters
 * - `sta: &STAHoldings`
 *     - A reference to the `STAHoldings` object, which contains the STA graph, netlist database,
 *       and liberty library information.
 * - `from_pin_rf: usize`
 *     - The "from" pin with a rise/fall flag. The actual pin ID is extracted by shifting right (>> 1).
 * - `to_pin_rf: usize`
 *     - The "to" pin with a rise/fall flag. The actual pin ID is extracted by shifting right (>> 1).
 *
 * ## Returns
 * - `f32`
 *     - Returns the arc delay in timing path (ps).
 *     - If the pins are invalid (no timing arc or incorrect direction), the function returns `NaN`.
 */
float heterosta_get_cell_arc_delay(const struct STAHoldings *sta,
                                   uintptr_t from_pin_rf,
                                   uintptr_t to_pin_rf);

/**
 * Calculate the intrinsic delay of a cell based on the specified input/output points and conditions.
 *
 * This function computes the intrinsic delay between the specified `from` and `to` pin types.
 *
 * Parameters:
 * - sta: Pointer to the STAHoldings object.
 * - celltype: C string representing the cell type.
 * - from_pintype: C string representing the starting pin type.
 * - to_pintype: C string representing the destination pin type.
 * - from_rf: Rise/Fall state of the `from` point (0: rise, 1: fall).
 * - to_rf: Rise/Fall state of the `to` point (0: rise, 1: fall).
 *
 * Returns:
 * - The intrinsic delay as a float.
 */
float heterosta_get_cell_intrinsic_delay(const struct STAHoldings *sta,
                                         const char *celltype,
                                         const char *from_pintype,
                                         const char *to_pintype,
                                         TimerRiseOrFall from_rf,
                                         TimerRiseOrFall to_rf);

/**
 * Query the drive resistance of a cell based on the specified input/output points.
 *
 * This function query the drive resistance of a cell based on the specified input/output points.
 *
 * Parameters:
 * - sta: Pointer to the STAHoldings object.
 * - celltype: C string representing the cell type.
 * - from_pintype: C string representing the starting pin type.
 * - to_pintype: C string representing the destination pin type.
 * - from_rf: Rise/Fall state of the `from` point (0: rise, 1: fall).
 * - to_rf: Rise/Fall state of the `to` point (0: rise, 1: fall).
 * - early_or_late: early lib or late lib (0: early, 1: late).
 *
 * Returns:
 * - The drive resistance as a float, NAN if nonexists.
 */
float heterosta_query_drive_resistance(const struct STAHoldings *sta,
                                       const char *celltype,
                                       const char *from_pintype,
                                       const char *to_pintype,
                                       TimerRiseOrFall from_rf,
                                       TimerRiseOrFall to_rf,
                                       TimerEarlyOrLate early_or_late);

/**
 * Get the footprint of a cell based on its type.
 *
 * This function retrieves the footprint (physical representation) of a cell
 * based on the provided cell type and timing context (early or late).
 *
 * Parameters:
 * - sta: Reference to the STAHoldings object containing cell data.
 * - celltype: C string representing the cell type.
 * - early_or_late: Timing context (0: early, 1: late).
 *
 * Returns:
 * - A pointer to a C string containing the footprint, or null if the cell type is not found.
 */
const char *heterosta_get_footprint_by_celltype(const struct STAHoldings *sta,
                                                const char *celltype,
                                                TimerEarlyOrLate early_or_late);

/**
 * Get a list of cell types associated with a given footprint.
 *
 * This function retrieves a list of cell types that share the same footprint
 * (physical representation) based on the provided footprint and timing context.
 * Will skip dont_use and dont_touch cell.
 *
 * Parameters:
 * - sta: Reference to the STAHoldings object containing cell data.
 * - footprint: C string representing the footprint.
 * - output_len: Pointer to a variable where the length of the returned array will be stored.
 * - early_or_late: Timing context (0: early, 1: late).
 *
 * Returns:
 * - A pointer to an array of C strings containing the cell types, or null if the footprint is not found.
 */
const char *const *heterosta_get_celltypes_by_footprint(const struct STAHoldings *sta,
                                                        const char *footprint,
                                                        uintptr_t *output_len,
                                                        TimerEarlyOrLate early_or_late);

/**
 * Free a previously allocated list of cell types.
 *
 * This function releases the memory allocated for a list of cell types
 * returned by `heterosta_get_celltypes_by_footprint`.
 *
 * Parameters:
 * - celltypes: Pointer to the array of C strings to be freed.
 * - len: Length of the array.
 */
void heterosta_free_celltypes_list(const char *const *celltypes, uintptr_t len);

/**
 * Get the git version description string.
 *
 * Returns a pointer to a null-terminated C string containing version information
 * obtained from git during build. This pointer is valid for the lifetime of the
 * application and should not be freed.
 */
const char *heterosta_get_version(void);

/**
 * Enables or disables the print count limit for the logger.
 * This function allows you to control whether the logger should limit the number of printed messages.
 * - `enable`: A boolean value indicating whether to enable or disable the print count limit.
 * - If `true`, the logger will limit the number of printed messages.
 * - If `false`, the logger will print all messages without any limit.
 * This is useful for debugging or when you want to see all log messages without restrictions.
 */
void heterosta_logger_enable_print_count_limit(bool enable);

/**
 * Enables timer logs for a specific prefix.
 */
void heterosta_logger_enable_timer_prefix(const char *prefix);

/**
 * Resets the print count limit for the logger.
 * This function clears the internal counter that tracks the number of log messages printed.
 * It is useful for scenarios where you want to start fresh and count log messages from a clean state.
 */
void heterosta_logger_reset_print_count_limit(void);

/**
 * Dumps the netlist pin names to a CSV file.
 * This function retrieves all pin names from the netlist database
 * and writes them to a specified CSV file.
 * Parameters:
 * - `sta`: Reference to the STAHoldings structure containing the netlist database.
 * - `path`: A C string pointer to the file path where the CSV will be saved.
 * The file will be created if it does not exist, or overwritten if it does.
 * The CSV will contain a single column with the header "pin_name" followed by all pin names.
 */
void heterosta_debug_dump_netlist_pin_names(const struct STAHoldings *sta, const char *path);

/**
 * Free a C string allocated by Rust.
 * This function takes a pointer to a C string (char pointer) that was allocated
 * by Rust (e.g., using CString::into_raw) and frees the memory associated with it.
 * It is important to ensure that the pointer passed to this function was indeed
 * allocated by Rust to avoid undefined behavior.
 *
 */
void heterosta_free_c_string(char *s);

/**
 * Query the design-wide maximum transition limit from SDC constraints.
 *
 * Parameters:
 * - `sta`: A reference to the `STAHoldings` structure.
 * - `early_or_late`: Timing context (0: early, 1: late).
 *
 * Returns:
 * - The maximum allowed transition time (in time units) for the entire design.
 */
float heterosta_query_sdc_design_wide_max_transition(const struct STAHoldings *sta,
                                                     TimerEarlyOrLate early_or_late);

/**
 * Query the design-wide maximum fanout limit from SDC constraints.
 *
 * Parameters:
 * - `sta`: A reference to the `STAHoldings` structure.
 * - `early_or_late`: Timing context (0: early, 1: late).
 *
 * Returns:
 * - The maximum allowed fanout for the entire design.
 */
float heterosta_query_sdc_design_wide_max_fanout(const struct STAHoldings *sta,
                                                 TimerEarlyOrLate early_or_late);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* HETEROSTA_RS_BINDINGS_H */
